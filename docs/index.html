<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ammc: AVR Multi Motor Control</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ammc
   </div>
   <div id="projectbrief">AVR Multi Motor Control</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">AVR Multi Motor Control </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> This repo contains the entire codebase and documentation for the bachelor degree apprenticeship, which is supervised by Prof. Giorgio Grisetti and Drs. Barbara Bazzana.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>The project consists in a multi-motor control system. Each DC motor is individually handled by a dedicated standalone AVR controller. An Atmel AT2560 is used as master controller.</p>
<p>The master controller must:</p>
<ul>
<li>Communicate with the slaves (i.e. controllers handling individual motors) via the I2C protocol</li>
<li>Communicate with a PC via the serial (over USB) protocol</li>
</ul>
<p>The end user will interface just the master controller, using a TUI program which runs under POSIX-compliant OSes.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Features</h2>
<ul>
<li>Text-based client application for POSIX environments</li>
<li>Master and Slave(s) controller firmware</li>
<li>Fully binary Client-Master communication protocol on top of the serial interface</li>
<li>Fully binary Master-Slave communication protocol on top of the I2C interface</li>
<li>Up to 126 DC motors (limited by 7-bit I2C Slave addressing, <code>0x00</code> is reserved)</li>
<li>Ability to get and set the DC motors speed, individually</li>
<li>Software defined PID controller embedded in each Slave controller</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Documentation</h2>
<p>An overview of the project is given in this Markdown document.</p>
<p>Documentation generated with doxygen for the source code and the programming API can be found <a href="https://jcondor98.github.io/ammc/">here</a>.</p>
<p>The client is documented by the man page <code>ammc(1)</code>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Professor Reference</h2>
<p>Quoting from <a href="https://gitlab.com/grisetti/sistemi_operativi_2020_21/-/blob/master/projects_preliminary/readme.md">Prof. Grisetti's repository</a>:</p>
<blockquote class="doxtable">
<p>[...]</p>
<ol type="1">
<li><b>Arduino TWI communication</b> &mdash;&gt; <code>[x2]</code> <code>[C98]</code> Use two (or more arduino), one configured as master the other ones as slaves Implement an interrupt based interaction protocol on i2c [<a href="http://www.chrisherring.net/all/tutorial-interrupt-driven-twi-interface-for-avr-part1/">http://www.chrisherring.net/all/tutorial-interrupt-driven-twi-interface-for-avr-part1/</a>. The protocol should contain the following messages:</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Direction   </th><th class="markdownTableHeadCenter">Command   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>master -&gt; all</code>   </td><td class="markdownTableBodyCenter"><code>sample</code>   </td><td class="markdownTableBodyNone">the slaves sample all digital inputs and puts them in a struct    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>master -&gt; slave[i] -&gt;master</code>   </td><td class="markdownTableBodyCenter"><code>get</code>   </td><td class="markdownTableBodyNone">the slave number <em>i</em> sends the sampled digital inputs to the master    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>master -&gt; slave[i]</code>   </td><td class="markdownTableBodyCenter"><code>set</code>   </td><td class="markdownTableBodyNone">the master sends to the slave <em>i</em> the desired output pin configuration in an internal struct, "without" applying it    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>master -&gt; all</code>   </td><td class="markdownTableBodyCenter"><code>apply</code>   </td><td class="markdownTableBodyNone">the slaves apply the saved pin status to the outputs   </td></tr>
</table>
<p>The slaves react only to interrupts. they are in halt status. The master offers an interface to the host (PC) program to control the slaves, via UART. All protocols are binary, packet based</p>
<ol type="1">
<li><b>Arduino motor controller</b> <code>[x1]</code> <code>[C98]</code> If you have a DC motor with encoder, implement a closed loop motor servo using a PID controller The arduino reads the encoder, and issues a PWM, so that the speed of the motor measured by the encoder matches a desired speed set by the user. The Host program allows to set a speed via uart, and the program on the arduino periodically sends back the status (pwm, encoder position, desired encoder speed and measured encoder speed)</li>
<li><b>Arduino multi motor control</b> <code>[x4]</code> <code>[C98]</code> integrate project 1 and project 2. Each slave controls a motor and communicates via i2c to the master that provides a unified interface. The event loop on the slaves is synchronized with the "apply" command.</li>
</ol>
<p>[...] </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md5"></a>
Installation</h1>
<p>The entire project uses the <em>GNU Make</em> build system. Client, Master and Slave programs' codebases are separated from each others.</p>
<p>A list of <em>make</em> recipes is given below: </p><div class="fragment"><div class="line"># Make client executables and master and slave .elf binaries</div>
<div class="line">make</div>
<div class="line"> </div>
<div class="line"># Compile and link the client-side executable</div>
<div class="line">make client</div>
<div class="line"> </div>
<div class="line"># Install the -ALREADY COMPILED- client-side executable</div>
<div class="line">sudo make install</div>
<div class="line"> </div>
<div class="line"># Generate man page (requires pandoc)</div>
<div class="line">make docs</div>
<div class="line"> </div>
<div class="line"># Install man page (pregenerated in the repo)</div>
<div class="line">sudo make install-docs</div>
<div class="line"> </div>
<div class="line"># Compile and link master .elf binary</div>
<div class="line">make master</div>
<div class="line"> </div>
<div class="line"># Compile and link slave .elf binary</div>
<div class="line">make slave</div>
<div class="line"> </div>
<div class="line"># Encode the master .elf binary into a .hex file and flash it into the AVR</div>
<div class="line">make master-flash</div>
<div class="line"> </div>
<div class="line"># Encode the slave .elf binary into a .hex file and flash it into the AVR</div>
<div class="line">make slave-flash</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Specification</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Client-Master communication</h2>
<p>The Client-Master communication protocol is binary, packet-based and built on top of the Serial-over-USB protocol offered by the AT2560 board. Each packet has a variable length and its integrity is checked with a trailing CRC-8 checksum.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Packet Header</h3>
<p>The header is composed of the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadCenter">Size (bits)   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>id</code>   </td><td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyNone">Packet ID    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>type</code>   </td><td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyNone">Packet type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>selector</code>   </td><td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyNone">Selector for DC motors. Also used to store error codes in NAK packets    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>size</code>   </td><td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyNone">Total packet size, including header and checksum   </td></tr>
</table>
<p><code>type</code> can have the following values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Type   </th><th class="markdownTableHeadCenter">Actual value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_NULL</code>   </td><td class="markdownTableBodyCenter"><code>0x00</code>   </td><td class="markdownTableBodyNone">Reserved, never use    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>COM_TYPE_HND</code>   </td><td class="markdownTableBodyCenter"><code>0x01</code>   </td><td class="markdownTableBodyNone">Handshake    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_ACK</code>   </td><td class="markdownTableBodyCenter"><code>0x02</code>   </td><td class="markdownTableBodyNone">Acknowledgement    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>COM_TYPE_NAK</code>   </td><td class="markdownTableBodyCenter"><code>0x03</code>   </td><td class="markdownTableBodyNone">Communication error    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_ECHO</code>   </td><td class="markdownTableBodyCenter"><code>0x04</code>   </td><td class="markdownTableBodyNone">[DEBUG] Echo between Client and Master    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>COM_TYPE_TWI_ECHO</code>   </td><td class="markdownTableBodyCenter"><code>0x05</code>   </td><td class="markdownTableBodyNone">[DEBUG] Echo a single char to the first Slave via TWI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_GET_SPEED</code>   </td><td class="markdownTableBodyCenter"><code>0x06</code>   </td><td class="markdownTableBodyNone">Get the current speed for a DC motor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>COM_TYPE_SET_SPEED</code>   </td><td class="markdownTableBodyCenter"><code>0x07</code>   </td><td class="markdownTableBodyNone">Set (and apply) the speed for a DC motor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_APPLY</code>   </td><td class="markdownTableBodyCenter"><code>0x08</code>   </td><td class="markdownTableBodyNone">Tell all the slaves to apply the previously set speeds    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>COM_TYPE_DAT</code>   </td><td class="markdownTableBodyCenter"><code>0x09</code>   </td><td class="markdownTableBodyNone">Primarily used for responses from the AVR device    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>COM_TYPE_LIMIT</code>   </td><td class="markdownTableBodyCenter"><code>0x0A</code>   </td><td class="markdownTableBodyNone">Used for sanity checks - Must have highest value   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md9"></a>
Acknowledgements</h3>
<p>A communication endpoint must wait for an acknowledgement message from the counterpart once it sent a packet in order to send a new one. ACK and NAK packets do not bring any data.</p>
<p>When a packet arrives, it is checked for integrity and sanity. If it is sane, then an ACK packet is sent; if not, then a NAK packet is sent. ACK and NAK packets are simply discarded if corrupted in some way.</p>
<p>A NAK packet uses the 'selector' field to send to the other endpoint the error code describing what happened on its side. Error codes can be found in <code>communication.h</code>.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Controlling DC motors' speed</h3>
<p>The master controller offers an upper-level, command-based API to handle the DC motors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Client command   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>get-speed &lt;motor_id&gt;</code>   </td><td class="markdownTableBodyNone">Get the speed of a DC motor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>set-speed &lt;motor_id&gt;=&lt;speed&gt;</code>   </td><td class="markdownTableBodyNone">Set the speed of a DC motor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>apply</code>   </td><td class="markdownTableBodyNone">Apply the previously set speeds to all the DC motors   </td></tr>
</table>
<p>Further informations can be found in the man page or by issuing the <code>help</code> command to the client shell.</p>
<p><b>NOTE</b>: The <code>sample</code> command has been removed from the specification, since the effective speed is periodically sampled by each Slave, as needed by the PID embedded controller.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Master-Slave communication</h2>
<p>Master and slaves communicate to each other using the TWI/I2C protocol. The implementation had been realized from scratch and also offers broadcasting capabilities from master to slaves, based on the <code>0x00</code> built-in broadcasting address.</p>
<p>The communication layer on top of the I2C protocol is completely binary.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Communication frame</h3>
<p>The I2C communication frame is composed of a leading byte representing the code of the command to be executed by the slave controller, and a variable size trailing argument. The commands are listed below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Command   </th><th class="markdownTableHeadCenter">Code   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>DC\_MOTOR\_CMD\_GET</code>   </td><td class="markdownTableBodyCenter"><code>0x00</code>   </td><td class="markdownTableBodyNone">Get the sampled motor speed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>DC\_MOTOR\_CMD\_SET</code>   </td><td class="markdownTableBodyCenter"><code>0x01</code>   </td><td class="markdownTableBodyNone">Set a new target speed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>DC\_MOTOR\_CMD\_APPLY</code>   </td><td class="markdownTableBodyCenter"><code>0x02</code>   </td><td class="markdownTableBodyNone">Apply the previously set speed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>TWI\_CMD\_ECHO</code>   </td><td class="markdownTableBodyCenter"><code>0x03</code>   </td><td class="markdownTableBodyNone">Echo a byte back to master (debug)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>TWI\_CMD\_SET\_ADDR</code>   </td><td class="markdownTableBodyCenter"><code>0x04</code>   </td><td class="markdownTableBodyNone">Change the current I2C address (i.e. motor id)   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md13"></a>
Notes</h1>
<p>The doxygen custom CSS files is taken from <em>jothepro</em>, <a href="https://github.com/jothepro/doxygen-awesome-css/blob/v1.6.0/LICENSE">here</a>. It is released under the MIT license. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
