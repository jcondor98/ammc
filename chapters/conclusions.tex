\chapter{Conclusions}
\label{ch:conclusions}
In this work I developed an electrical motor handling hardware/software
solution with modularity and extensibility in mind. In this very final chapter
I demonstrate how ammc can be used in practice and I explain how it could be
developed further in the future.

\section{Example setup}

\subsection{Hardware}
The hardware required for the example setup given here is the following:
\begin{itemize}
  \item One \emph{ATMega2560} microcontroller unit for the master controller
  \item One \emph{ATMega2560} microcontroller unit for the slave controller
  \item One dc motor with embedded two-phase encoder
  \item Two $4.7 k\Omega$ resistors for the I2C open-drain
  \item One capacitor of about $100 pF$ to inhibit the reset-over-serial
    capabilities of the ATMega2560 board
  \item One h-bridge driver consistent with the dc motor voltage and power
    requirements (e.g.\ $12 V,\ 2 A$)
  \item A power supply compatible with the h-bridge and motor voltage and
    power requirements (e.g.\ $12 V,\ 24 W$)
\end{itemize}

The hardware setup must be performed as shown in figures \ref{img:master-sch}
and \ref{img:slave-sch}.
The motor must be powered consistently with its requirements. The AVR
microcontrollers can be powered using their USB sockets. The I2C reference
voltage can be set by using a $5 V$ output pin of the master controller board.

\subsection{Software}
The software can be built and eventually flashed using GNU Make. the
\emph{avr-gcc} toolchain and the \emph{avr-libc} library are required for the
build, while \emph{avrdude} is required for flashing.

The \texttt{make} command will build all the ammc software, i.e.\ the master
and slave controllers firmwares and the client application. The \texttt{make
master-flash} and the \texttt{make slave-flash} commands will flash the master
and slave firmwares into their respective microcontrollers.

At last, the user may want to use the \texttt{set-slave-addr} command to assign
an arbitrary address to the only slave controller.

\section{Future work}

\subsection{Extended connectivity}
The extension of the master controller connectivity would make ammc suitable
for whole new range of application possibilities. For example, \emph{LoRaWAN}
and similar communication vectors would make ammc a motor management system
suitable for dc motor distributed in a wide-area. The use of multiple wired
low-level communication means such as SPI or raw serial ports would make ammc
suitable for a multi-master, multi-group setup.

\subsection{Programming API}
The client application offers a non-interactive mode for basic scriping
functionality. Thus it is good for basic automation, it is quite limited when
more complex features are required, such as an advanced use of logic or control
flow capabilities. For this purpose, the implementation of a programming API,
eventually with bindings in various languages, would make the ammc
functionality directly available to the programmer as high-level functions.
