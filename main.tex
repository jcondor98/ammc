% Bachelor Degree Thesis - Paolo Lucchesi
% !TeX encoding = UTF-8
% !TeX program = pdflatex
% !TeX spellcheck = en_US

\documentclass[binding=0.6cm,Lau]{sapthesis}
\usepackage{microtype}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\hypersetup{pdftitle={AVR Multi Motor Control},pdfauthor={Paolo Lucchesi}}

\title{AVR Multi Motor Control}
\author{Paolo Lucchesi}
\IDnumber{1765134}
\course{Ingegneria Informatica e Automatica}
\courseorganizer{Facolt√† di Ingegneria dell'Informazione, Informatica e Statistica}
\AcademicYear{2021/2022}
\copyyear{2021}
\advisor{Prof. Giorgio Grisetti}
\advisor{Drs. Barbara Bazzana}
\reviewerlabel{Reviewer}
\reviewer{Prof. Silvia Bonomi}
\authoremail{lucchesi.1765134@studenti.uniroma1.it}
\website{https://github.com/jcondor98/ammc}


\begin{document}

\frontmatter
\maketitle

\dedication{
Dedicated to my family, my granddad Pietro, my mom Anna Rosa, my dad Marco,
my grandmom Pierina and my sister Valentina, which I thank everyday for
everything I am.\\
To my dearest friends in Pitigliano, with whom I share some of the most
beautiful memories I have.\\
To Nicola, with whom I have shared part of this path; he helped me in a
dark period of my life and he is one of my dearest friends.
}

\begin{abstract}
\end{abstract}

\tableofcontents


\mainmatter

\chapter{Introduction}
\label{ch:intro}


\chapter{Client-side user interaction}
\label{ch:client}
A client program has been realized to manipulate the dc motors directly from the
PC. It can get and set the speed of individual motors, and to apply all the
previously set speeds for all of them at once.\\ A brief list of the
client's features is given below:
\begin{itemize}
  \item Granular handling for getting and setting motors' speed
  \item Modular and extensible software architecture
  \item Terminal User Interface, implemented as a command shell
  \item Support for non-interactive use (i.e.\ scripting)
  \item Communication with master controller using the serial protocol
  \item Compatible with POSIX-compliant environments
\end{itemize}
The client is also documented with a man page, which can be found in section
\ref{sec:client-manpage}.

\section{User Interface}
The end user interacts with the whole ammc ecosystem using a text-based client.
It consists in a shell module, which I had written myself, offering some
\emph{internal commands} (hardcoded in the shell module itself) and is extended
by \emph{external commands} (found in a separated source code entity, and that
can even be compiled in a detached transaction unit).

A particular focus was made on the software architecture: indeed, every
external command can be realized standalone, and it is easy to add new
commands just by altering the \emph{client/source/shell\_commands.c} source
file.

\section{Primitives offered}
The commands that can be used to interface with the ammc ecosystem are the
following:
\begin{description}
  \item[connect <device-path>] Connect to a master controller, given the path
    to the block device representing it.
  \item[get-speed <motor-id>] Get the speed of a dc motor given its id.
    The motor id must be specified as a decimal number.
  \item[set-speed <motor-id>=<speed>] Set the speed of a dc motor given its id.
    The motor id must be specified as a decimal number and the speed must be
    specified in rpm.
  \item[apply] Apply the previously set speed for all the dc motors.
\end{description}

\subsection{Non-interactive mode}
The client shell is capable of running in non-interactive (i.e.\ scripting)
mode with the \emph{-s} option.  If so, it will parse the input from a
specified text file, or from \emph{stdin} if not provided.  A shell launched in
non-interactive mode will not print shell prompts, and exit when end-of-file is
encountered or on command failure.

\section{Serial module}
The client's serial module has been realized using the POSIX \emph{termios}
interface. Unlike the master controller's counterpart, all its code is
reentrant, therefore multiple instances of multiple serial devices can
theoretically exist at the same time.

From the client's perspective, the master controller is seen as a file
descriptor, and the end user just have to specify the path of the block device
file representing the serial communication channel (e.g. \emph{/dev/ttyACM0})
using the \emph{connect} command.

\section{Specification}
\subsection{Software modules}
\subsection{Modules dependency graph}

\section{Man page}
\label{sec:client-manpage}


\chapter{Master controller}
\label{ch:master}
The master controller handles all the slave controllers, dispaching arbitrary
commands to them using the I2C protocol. It also communicates directly with the
client application via serial port.

\section{Hardware setup}
The master controller itself is an AVR \emph{ATMega2560} microcontroller unit\cite{at2560-ref}.
This particular MCU has features convenient for this project, such as:
\begin{itemize}
  \item I2C dedicated hardware subsystem
  \item Serial-over-USB bridge
  \item Relatively powerful specifications for future feature adding
  \item Plenty of timers and outgoing power pins
\end{itemize}

A $100 pF$ capacitor is used to block the reset capabilities of the
serial-over-usb controller and enhance the serial channel reliability. Two
$4.7 k\Omega$ resistors are used as open-drain resistors for the I2C bus.

\section{I2C setup}
The I2C protocol is used to communicate with slave controllers. Transmission
and reception are interrupt-based, and no busy-wait is used.

The I2C module has broadcasting capabilities, according to the informations
found in the I2C standard I2C standard\cite{i2c-ref}; the broadcasting (i.e.\
\emph{general call}) address used is $0x00$. As stated by the standard, the
master controller has no knowledge on the number or identity of the slaves
receiving a broadcast frame.

\section{Power management}
An own-written wrapper for the avr-gcc standard library's sleep functionalities is used for power management.
By default, the master controller is in \emph{idle} mode, and it is awakened by
any raised interrupt, e.g.\ by incoming serial or I2C data; then, its main loop
routine is executed and, if no other operations must be performed, it returns
in idle mode.

The master controller is also put in idle when waiting for data inside serial
or I2C routines; this is possible thanks to the interrupt-driven nature of the
aforementioned modules.

\section{Specification}
\subsection{Software modules}
\subsection{Modules dependency graph}
\subsection{Circuit schematics}
\subsection{Wiring}


\chapter{Slave controllers}
\label{ch:slave}
Each slave controller directly handles a single dc motor, receiving commands
from the master controller via I2C. It must offer an interface to get and
manipulate its motor's speed.

The slave controller produces a PWM wave having a duty cycle consistent with
the speed (given in RPM) specified by the end user in order to control its
motor.

Furthermore, it comes with a software Proportional-Integral-Derivative
controller to correct the bias between target and actual motor speeds.

\section{Hardware setup}
The slave controller itself is an AVR \emph{ATMega328P} microcontroller
unit\cite{at328p-ref}, which offers the following features of interest:

\begin{itemize}
  \item CH340 Serial-over-USB controller for convenient firmware flashing
  \item Reduced size
  \item Relatively high clock and resources
  \item Dedicated I2C hardware subsystem
  \item PWM-capable 8-bit and 16-bit timers
\end{itemize}

Apart from the motor itself (along with its power supply and eventually its
dedicated control board) no additional hardware is used.

\section{I2C setup}
A slave controller communicates with the master controller using the I2C
protocol. As for the master controller, both transmission and reception are
interrupt-based.

The slave controller is always passive on the bus, waiting to be addressed by
the master.

% TODO: Dynamic addressing

\section{Proportional-Integral-Derivative controller}
An own-written, software-defined Proportional-Integral-Derivative controller is
used to correct the actual motor speed. As for any PID device, the equation
controlling the error is:
\begin{equation}
  u(t) = K_p e(t) + K_i \int_{t_0}^t e(\tau)\,d\tau + K_d \frac{d}{dt}\,e(t)
\end{equation}
being:
\begin{itemize}
  \item $u(t)$ the PID control variable
  \item $K_p$ the proportional gain
  \item $K_i$ the integral gain
  \item $K_d$ the derivative gain
  \item $e(t)$ the measured speed error
\end{itemize}

\subsection{Measuring speed}
For actual PID capabilities, the slave controller must sample the actual speed
of the dc motor at fixed intervals. Therefore, the motor must have an embedded,
two-phase digital encoder.

In fact, one phase is wired to an interrupt-enabled input pin, so the slave
controller is notified immediately when an encoder signal (raising edge) is
generated. Every sampling intervals, the PID routine takes the motor's actual
position (measured by the cumulative number of encoder triggers) and computes
its real speed.

\subsection{Approximations}
Of course, a software digital PID controller can not compute exact integrals
and derivatives, so it is necessary to use approximation.

The integral operation is approximated using \emph{Riemann sums}. Given a time
delta $\Delta t$ (the actual speed sampling interval in this particular case),
the approximating law is defined as:
\begin{equation}
  \int_{t_0}^t e(\tau)\,d\tau \approx \sum_{k=1}^n e(t_k^*) \cdot \Delta t
\end{equation}
The derivative operation is approximated using its
definition\cite{levy-num-analysis}:
\begin{equation}
  \frac{d}{dt}\,e(t) = \lim_{\Delta t \to 0} \frac{e(t + \Delta t) - e(t)}{\Delta t} \implies
  \frac{d}{dt}\,e(t) \approx \frac{e(t + \Delta t) - e(t)}{\Delta t}
\end{equation}
being $\Delta t$ a time delta (again, the actual speed sampling interval).

\section{Power management}
The same avr-libc wrapper written for the master controller power management is
used.
By default, the slave controller is in \emph{idle} mode, and it is awakened by
any raised interrupt. The main loop routine is executed and the idle mode is
entered again. Like for the master controller, the slave is put in idle when
waiting for the I2C routines to return.

The AVR idle mode allows the timers to work, so the slave controller can
generate PWM waves to control the motors, even while sleeping.

\section{Specification}
\subsection{Software modules}
\subsection{Modules dependency graph}
\subsection{Circuit schematics}
\subsection{Wiring}

\chapter{Client-Master communication}
\label{ch:client-master-comm}

\chapter{Master-Slave communication}
\label{ch:master-slave-comm}

\chapter{Conclusions}
\label{ch:conclusions}


\backmatter
\cleardoublepage
\phantomsection % Give this command only if hyperref is loaded

\addcontentsline{toc}{chapter}{\bibname}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
