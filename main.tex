% Bachelor Degree Thesis - Paolo Lucchesi
% !TeX encoding = UTF-8
% !TeX program = pdflatex
% !TeX spellcheck = en_US

\documentclass[binding=0.6cm,Lau]{sapthesis}
\usepackage{microtype}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{tabularx}

\hypersetup{pdftitle={AVR Multi Motor Control},pdfauthor={Paolo Lucchesi}}

\title{AVR Multi Motor Control}
\author{Paolo Lucchesi}
\IDnumber{1765134}
\course{Ingegneria Informatica e Automatica}
\courseorganizer{Facolt√† di Ingegneria dell'Informazione, Informatica e Statistica}
\AcademicYear{2021/2022}
\copyyear{2021}
\advisor{Prof. Giorgio Grisetti}
\advisor{Drs. Barbara Bazzana}
\reviewerlabel{Reviewer}
\reviewer{Prof. Silvia Bonomi}
\authoremail{lucchesi.1765134@studenti.uniroma1.it}
\website{https://github.com/jcondor98/ammc}


\begin{document}

\frontmatter
\maketitle

\dedication{
Dedicated to my family, my granddad Pietro, my mom Anna Rosa, my dad Marco,
my grandmom Pierina and my sister Valentina, which I thank everyday for
everything I am.\\
To my dearest friends in Pitigliano, with whom I share some of the most
beautiful memories I have.\\
To Nicola, with whom I have shared part of this path; he helped me in a
dark period of my life and he is one of my dearest friends.
}

\begin{abstract}
\end{abstract}

\tableofcontents


\mainmatter

\chapter{Introduction}
\label{ch:intro}


\chapter{Client-side user interaction}
\label{ch:client}
A client program has been realized to manipulate the dc motors directly from the
PC. It can get and set the speed of individual motors, and to apply all the
previously set speeds for all of them at once.\\ A brief list of the
client's features is given below:
\begin{itemize}
  \item Granular handling for getting and setting motors' speed
  \item Modular and extensible software architecture
  \item Terminal User Interface, implemented as a command shell
  \item Support for non-interactive use (i.e.\ scripting)
  \item Communication with master controller using the serial protocol
  \item Compatible with POSIX-compliant environments
\end{itemize}
The client is also documented with a man page, which can be found in section
\ref{sec:client-manpage}.

\section{User Interface}
The end user interacts with the whole ammc ecosystem using a text-based client.
It consists in a shell module, which I had written myself, offering some
\emph{internal commands} (hardcoded in the shell module itself) and is extended
by \emph{external commands} (found in a separated source code entity, and that
can even be compiled in a detached transaction unit).

A particular focus was made on the software architecture: indeed, every
external command can be realized standalone, and it is easy to add new
commands just by altering the \emph{client/source/shell\_commands.c} source
file.

\section{Primitives offered}
The commands that can be used to interface with the ammc ecosystem are the
following:
\begin{description}
  \item[connect <device-path>] Connect to a master controller, given the path
    to the block device representing it.
  \item[get-speed <motor-id>] Get the speed of a dc motor given its id.
    The motor id must be specified as a decimal number.
  \item[set-speed <motor-id>=<speed>] Set the speed of a dc motor given its id.
    The motor id must be specified as a decimal number and the speed must be
    specified in rpm.
  \item[apply] Apply the previously set speed for all the dc motors.
\end{description}

\subsection{Non-interactive mode}
The client shell is capable of running in non-interactive (i.e.\ scripting)
mode with the \emph{-s} option.  If so, it will parse the input from a
specified text file, or from \emph{stdin} if not provided.  A shell launched in
non-interactive mode will not print shell prompts, and exit when end-of-file is
encountered or on command failure.

\section{Serial module}
The client's serial module has been realized using the POSIX \emph{termios}
interface. Unlike the master controller's counterpart, all its code is
reentrant, therefore multiple instances of multiple serial devices can
theoretically exist at the same time.

From the client's perspective, the master controller is seen as a file
descriptor, and the end user just have to specify the path of the block device
file representing the serial communication channel (e.g. \emph{/dev/ttyACM0})
using the \emph{connect} command.

\section{Specification}

\subsection{Software modules}
An exhaustive list of software modules for the client application is given
in table \ref{tab:client-spec-modules}. File paths are relative to the
\emph{client/} directory.

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c X X}
    \toprule
    Module & Description & Files \\
    \midrule
    communication &
      Contains all the top-level communication routines &
      include/communication.h, source/communication.c \\
    crc &
      Contains the CRC generation and checking routines &
      include/crc.h, source/crc.c \\
    debug &
      Contains convenient debug facilities &
      include/debug.h \\
    main &
      Contains the main client application routine &
      source/main.c \\
    packet &
      Contains packet generation and manipulation routines &
      include/packet.h, source/packet.c \\
    ringbuffer &
      Circular buffer implementation for the serial module &
      include/ringbuffer.h, source/ringbuffer.c \\
    serial &
      Contains all the routines for the underlying serial communication layer &
      include/serial.h, source/serial.c \\
    shell &
      Main program shell with built-in commands &
      include/shell.h, source/shell.c \\
    shell\_commands &
      Contains the custom external commands to interact with the master controller &
      source/shell\_commands.c \\
    \bottomrule
  \end{tabularx}
  \caption{Client application software modules}
  \label{tab:client-spec-modules}
\end{table}

\subsection{Modules dependency graph}

\section{Man page}
\label{sec:client-manpage}


\chapter{Master controller}
\label{ch:master}
The master controller handles all the slave controllers, dispaching arbitrary
commands to them using the I2C protocol. It also communicates directly with the
client application via serial port.

\section{Hardware setup}
The master controller itself is an AVR \emph{ATMega2560} microcontroller unit\cite{at2560-ref}.
This particular MCU has features convenient for this project, such as:
\begin{itemize}
  \item I2C dedicated hardware subsystem
  \item Serial-over-USB bridge
  \item Relatively powerful specifications for future feature adding
  \item Plenty of timers and outgoing power pins
\end{itemize}

A $100 pF$ capacitor is used to block the reset capabilities of the
serial-over-usb controller and enhance the serial channel reliability. Two
$4.7 k\Omega$ resistors are used as open-drain resistors for the I2C bus.

\section{I2C setup}
The I2C protocol is used to communicate with slave controllers. Transmission
and reception are interrupt-based, and no busy-wait is used.

The I2C module has broadcasting capabilities, according to the informations
found in the I2C standard I2C standard\cite{i2c-ref}; the broadcasting (i.e.\
\emph{general call}) address used is $0x00$. As stated by the standard, the
master controller has no knowledge on the number or identity of the slaves
receiving a broadcast frame.

\section{Power management}
An own-written wrapper for the avr-gcc standard library's sleep functionalities is used for power management.
By default, the master controller is in \emph{idle} mode, and it is awakened by
any raised interrupt, e.g.\ by incoming serial or I2C data; then, its main loop
routine is executed and, if no other operations must be performed, it returns
in idle mode.

The master controller is also put in idle when waiting for data inside serial
or I2C routines; this is possible thanks to the interrupt-driven nature of the
aforementioned modules.

\section{Specification}

\subsection{Software modules}
An exhaustive list of software modules for the master controller firmware is
given in table \ref{tab:master-spec-modules}. File paths are relative to the
\emph{master/} directory.

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c X X}
    \toprule
    Module & Description & Files \\
    \midrule
    communication &
      Contains all the top-level communication routines &
      include/communication.h, source/communication.c \\
    crc &
      Contains the CRC generation and checking routines &
      include/crc.h, source/crc.c \\
    dcmotor &
      Contains the top-level routines for interfacing slave controllers &
      include/dcmotor.h, source/dcmotor.c \\
    main &
      Contains the main and power management routines &
      source/main.c \\
    ringbuffer &
      Circular buffer implementation for the serial module &
      include/ringbuffer.h, source/ringbuffer.c \\
    serial &
      Contains all the routines for the underlying serial communication layer &
      include/serial.h, source/serial.c \\
    sleep\_util &
      Handy wrapper for the avr-libc power management facilities &
      include/sleep\_util.h \\
    twi &
      Contains the I2C/TWI layer which underlies the communication between master and slaves &
      include/twi.h, source/twi.c \\
    \bottomrule
  \end{tabularx}
  \caption{Master application software modules}
  \label{tab:master-spec-modules}
\end{table}


\subsection{Modules dependency graph}

\subsection{Circuit schematics}

\subsection{Wiring}


\chapter{Slave controllers}
\label{ch:slave}
Each slave controller directly handles a single dc motor, receiving commands
from the master controller via I2C. It must offer an interface to get and
manipulate its motor's speed.

The slave controller produces a PWM wave having a duty cycle consistent with
the speed (given in RPM) specified by the end user in order to control its
motor.

Furthermore, it comes with a software Proportional-Integral-Derivative
controller to correct the bias between target and actual motor speeds.

\section{Hardware setup}
The slave controller itself is an AVR \emph{ATMega328P} microcontroller
unit\cite{at328p-ref}, which offers the following features of interest:

\begin{itemize}
  \item CH340 Serial-over-USB controller for convenient firmware flashing
  \item Reduced size
  \item Relatively high clock and resources
  \item Dedicated I2C hardware subsystem
  \item PWM-capable 8-bit and 16-bit timers
\end{itemize}

Apart from the motor itself (along with its power supply and eventually its
dedicated control board) no additional hardware is used.

\section{I2C setup}
A slave controller communicates with the master controller using the I2C
protocol. As for the master controller, both transmission and reception are
interrupt-based.

The slave controller is always passive on the bus, waiting to be addressed by
the master.

% TODO: Dynamic addressing

\section{Proportional-Integral-Derivative controller}
An own-written, software-defined Proportional-Integral-Derivative controller is
used to correct the actual motor speed. As for any PID device, the equation
controlling the error is:
\begin{equation}
  u(t) = K_p e(t) + K_i \int_{t_0}^t e(\tau)\,d\tau + K_d \frac{d}{dt}\,e(t)
\end{equation}
being:
\begin{itemize}
  \item $u(t)$ the PID control variable
  \item $K_p$ the proportional gain
  \item $K_i$ the integral gain
  \item $K_d$ the derivative gain
  \item $e(t)$ the measured speed error
\end{itemize}

\subsection{Measuring speed}
For actual PID capabilities, the slave controller must sample the actual speed
of the dc motor at fixed intervals. Therefore, the motor must have an embedded,
two-phase digital encoder.

In fact, one phase is wired to an interrupt-enabled input pin, so the slave
controller is notified immediately when an encoder signal (raising edge) is
generated. Every sampling intervals, the PID routine takes the motor's actual
position (measured by the cumulative number of encoder triggers) and computes
its real speed.

\subsection{Approximations}
Of course, a software digital PID controller can not compute exact integrals
and derivatives, so it is necessary to use approximation.

The integral operation is approximated using \emph{Riemann sums}. Given a time
delta $\Delta t$ (the actual speed sampling interval in this particular case),
the approximating law is defined as:
\begin{equation}
  \int_{t_0}^t e(\tau)\,d\tau \approx \sum_{k=1}^n e(t_k^*) \cdot \Delta t
\end{equation}
The derivative operation is approximated using its
definition\cite{levy-num-analysis}:
\begin{equation}
  \frac{d}{dt}\,e(t) = \lim_{\Delta t \to 0} \frac{e(t + \Delta t) - e(t)}{\Delta t} \implies
  \frac{d}{dt}\,e(t) \approx \frac{e(t + \Delta t) - e(t)}{\Delta t}
\end{equation}
being $\Delta t$ a time delta (again, the actual speed sampling interval).

\section{Power management}
The same avr-libc wrapper written for the master controller power management is
used.
By default, the slave controller is in \emph{idle} mode, and it is awakened by
any raised interrupt. The main loop routine is executed and the idle mode is
entered again. Like for the master controller, the slave is put in idle when
waiting for the I2C routines to return.

The AVR idle mode allows the timers to work, so the slave controller can
generate PWM waves to control the motors, even while sleeping.

\section{Specification}

\subsection{Software modules}
An exhaustive list of software modules for the slave controllers firmware is
given in table \ref{tab:slave-spec-modules}. File paths are relative to the
\emph{slave/} directory.

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c X X}
    \toprule
    Module & Description & Files \\
    \midrule
    dcmotor &
      Contains stuff to directly manipulate dc motors, including the PID controller, PWM waves generation and speed manipulation routines &
      include/dcmotor.h, source/dcmotor.c \\
    main &
      Contains the main and power management routines &
      source/main.c \\
    sleep\_util &
      Handy wrapper for the avr-libc power management facilities &
      include/sleep\_util.h \\
    twi &
      Contains the I2C/TWI layer which underlies the communication between master and slaves &
      include/twi.h, source/twi.c \\
    \bottomrule
  \end{tabularx}
  \caption{Slave application software modules}
  \label{tab:slave-spec-modules}
\end{table}


\subsection{Modules dependency graph}
\subsection{Circuit schematics}
\subsection{Wiring}


\chapter{Client-Master communication}
\label{ch:client-master-comm}
The client application and the master controller communicate over a protocol
built on top of the serial-over-usb layer. Such protocol is completely binary
and packet-based. Each packet has a variable length (with a total maximum size
of 36 bytes) and its integrity is checked with a trailing CRC-8 checksum.

The protocol comes with a simple handshaking mechanism, in order to synchronize
the packet IDs between endpoints and as a shallow proof of correct
functionality of the communication layers.

\section{Serial layer}
Data exchange between client and master relies on the serial protocol. For the
client application, the \emph{termios} library is used, while for the master
controller the (hardware) serial subsystem offered by the AVR
microcontroller\cite{at2560-ref} is used.

The serial communication is set up as follows:
\begin{itemize}
  \item Baud rate of 115200 baud, double speed transmission
  \item 8 bit frame width
  \item No start bits, 1 stop bit (i.e.\ 8N1)
  \item No embedded parity bit
\end{itemize}

For the master controller, both transmission and reception are
interrupt-driven, so the communication main routine is only called when data is
actually available.

\section{Packet headers}
Each packet's metadata is contained in a fixed size header, composed as
describe in table \ref{tab:packet-header}.

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c c X}
    \toprule
    Field & Size (bits) & Description \\
    \midrule
    id       & 8 & Packet ID \\
    type     & 8 & Packet type \\
    selector & 8 & Selector for DC motors. Also used to store error codes in NAK packets \\
    size     & 8 & Total packet size, including header and checksum \\
    \bottomrule
  \end{tabularx}
  \caption{Packet header fields}
  \label{tab:packet-header}
\end{table}

\subsection{Identifiers}
The \emph{id} field stores the packet identifier, which is incremental and can
be repeated in a single communication session. When the handshake is performed,
or when any endpoint raises an error (issuing a \emph{NAK} packet), the id is
reset to zero for both sides. Each \emph{ACK} and \emph{NAK} packet is
generated with the same id of the referred packet (see TODO for further
informations).

\subsection{Packet types}
The \emph{type} field stores the packet type. An exhaustive list of packet types
is given in table \ref{tab:packet-types}

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c c X}
    \toprule
    Type & Code & Description \\
    \midrule
    NULL       & 0x00 & Reserved, never use \\
    HND        & 0x01 & Handshake \\
    ACK        & 0x02 & Acknowledgement \\
    NAK        & 0x03 & Communication error \\
    ECHO       & 0x04 & Echo between Client and Master (debug only)\\
    TWI\_ECHO  & 0x05 & Echo a single char to the first Slave via TWI (debug only)\\
    GET\_SPEED & 0x06 & Get the current speed for a DC motor \\
    SET\_SPEED & 0x07 & Set (and apply) the speed for a DC motor \\
    APPLY      & 0x08 & Tell all the slaves to apply the previously set speeds \\
    DAT        & 0x09 & Primarily used for responses from the AVR device \\
    LIMIT      & 0x0A & Used for sanity checks - Must have highest value \\
    \bottomrule
  \end{tabularx}
  \caption{Exhaustive list of packet types}
  \label{tab:packet-types}
\end{table}

\subsection{Motor selector}
The \emph{selector} field is used to store the identifier for the dc motor to
manipulate. This field is used in \emph{GET\_SPEED} and \emph{SET\_SPEED} packets.

For \emph{NAK} packets, instead, the \emph{selector} field is used to store
error codes (found in table \ref{tab:packet-error-codes}).

For all the other packet types, the \emph{selector} field is ignored.

\section{Acknowledgements and errors}
A communication endpoint must wait for an acknowledgement message from the
counterpart once it sent a packet in order to send a new one. ACK and NAK
packets do not bring any data.

When a packet arrives, it is checked for integrity and sanity. If it is sane,
then an ACK packet is sent; if not, then a NAK packet is sent.
ACK and NAK packets are simply discarded if corrupted in some way.

A NAK packet uses the \emph{selector} field to send to the other endpoint the
error code describing what happened on its side. Error codes are listed in
table \ref{tab:packet-error-codes}.

\begin{table}[bh]
  \begin{tabularx}{\textwidth}{c c X}
    \toprule
    Error & Code & Description \\
    \midrule
    SUCCESS             & 0x00 & No errors encountered \\
    ID\_MISMATCH        & 0x01 & Id of received packet is not consistent \\
    CORRUPTED\_CHECKSUM & 0x02 & Checksum mismatch, received packet is corrupted \\
    WRONG\_TYPE         & 0x03 & Received packet has invalid type \\
    TOO\_BIG            & 0x04 & Received packet has invalid size (too big) \\
    \bottomrule
  \end{tabularx}
  \caption{Exhaustive list of packet types}
  \label{tab:packet-error-codes}
\end{table}


\chapter{Master-Slave communication}
\label{ch:master-slave-comm}

\chapter{Conclusions}
\label{ch:conclusions}


\backmatter
\cleardoublepage
\phantomsection % Give this command only if hyperref is loaded

\addcontentsline{toc}{chapter}{\bibname}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
